<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[从Java 8 到Java 11 （语言篇）：一、局部变量类型接口]]></title>
    <url>%2F2018%2F09%2F30%2F1%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;局部变量类型接口是Java 10 为了提高代码的可读性而增加的一个语法糖。从网络调查的数据来看，这个新特性得到了广大开发者（74%）的认可。现在我们可以使用 var 替换局部变量声明时的类型部分，从而避免耗费精力去写出那些显而易见的类型。 什么是局部变量类型接口&emsp;&emsp;Java 10 采用了一个叫做 var 的保留类型来实现局部变量推断。在Java 10 之前，我们在定义局部变量的时候，必须要指定变量的具体类型: 1String text = "Hello Java 9"; 现在，可以使用var来代替具体的类型String。编译器将会根据上下文自动推断出变量的具体类型，那么上述代码可以修改为如下形式： 1var text = "Hello Java 10"; 值得特别注意的是，为了兼容旧版本，var 不是关键字，而是一个保留类型，也就意味着你仍然可以像这样用 var 为你的变量和函数命名： 1String var = "Hello Java"; &emsp;&emsp;与JavaScript等动态语言不同的是，Java中的 var 声明的变量仍旧是静态类型。你不能再次赋予另一个与原类型不符的变量值。 12var text = "Hello Java 10";text = 10; // Error：Type mismatch: cannot convert from int to String &emsp;&emsp;遗憾的是，Java 10 没有引入 Scala 和 Kotlin 中用于声明不可变变量的 val 关键字，而需要使用 final var 这种遗憾的语法来达到这个目的。 12final var text = "Hello Java 10";text = "Hello Java 11"; // Error：The final local variable text cannot be assigned. It must be blank and not using a compound assignment 局部变量类型接口的适用范围&emsp;&emsp;var 保留类型可以在定义如下类型的变量的时候使用。 字面量定义局部变量 123var list = new ArrayList&lt;String&gt;(); // infers ArrayList&lt;String&gt;var lst = new ArrayList&lt;&gt;();var text = "Hello Java 10"; 接收方法返回值定义局部变量 123var stream = list.stream(); // infers Stream&lt;String&gt;var path = Paths.get(fileName); // infers Pathvar bytes = Files.readAllBytes(path); // infers bytes[] 循环中定义局部变量 123List&lt;String&gt; lst = Arrays.asList("a", "b", "c");for (var element : lst) &#123;...&#125; // infers Stringfor (var counter = 0; counter &lt; lst.size(); counter++) &#123;...&#125; // infers int try-with-resources中定义的变量 12try (var input = new FileInputStream("validation.txt")) &#123;...&#125; // infers FileInputStream Lambda 表达式 &emsp;&emsp;这是Java 11 对var 保留类型的增强，为了代码的一致性，它允许在lamdba表达式中，声明隐式类型参数时使用var保留类型。例如，在Java 11之前，lamdba表达式需要只能这样写： 1BiFunction&lt;Integer, Integer, Integer&gt; fnc = (a, b) -&gt; a + b; 在 Java 11 和之后的版本，可以改写成这样： 1BiFunction&lt;Integer, Integer, Integer&gt; fnc = (var a,var b) -&gt; a + b; 需要注意的是，它不允许对lamdba表达式中的参数只有部分指定var保留类型，或者混合使用保留关键字和其他类型。 12fnc = (var a, b) -&gt; a + b; //ERROR: Syntax error on token "var"fnc = (var a, int b) -&gt; a + b; //ERROR: 'var' cannot be mixed with non-var parameters 局部变量类型接口的实现原理&emsp;&emsp;var其实就是 Java 10 增加的一种语法糖而已，在编译期间会自动推断实际类型，其编译后的字节码和实际类型一致，如以下所示： 12345public static void main(String[] args) &#123; String var = "Hello Java"; var text = "Hello Java 10"; System.out.println(var + "\n" + text);&#125; 其编译后的字节码如下： mark:3,512345678910111213141516171819public static void main(java.lang.String[]); Code: 0: ldc #16 // String Hello Java 2: astore_1 3: ldc #18 // String Hello Java 10 5: astore_2 6: getstatic #20 // Field java/lang/System.out:Ljava/io/PrintStream; 9: new #26 // class java/lang/StringBuilder 12: dup 13: aload_1 14: invokestatic #28 // Method java/lang/String.valueOf:(Ljava/lang/Object;)Ljava/lang/String; 17: invokespecial #34 // Method java/lang/StringBuilder."&lt;init&gt;":(Ljava/lang/String;)V 20: ldc #37 // String \n 22: invokevirtual #39 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 25: aload_2 26: invokevirtual #39 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 29: invokevirtual #43 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 32: invokevirtual #47 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 35: return 从上述代码的第3和5行可以看出，在编译后，虚拟机识别的仍是具体类型，而不是var类型。 局部变量类型接口的优缺点&emsp;&emsp;局部变量类型接口的引入，其最大的好处是简化了代码，增强了代码的可读性，让Java代码更加简洁。例如，在Java 10 之前，一般代码会写成这样： 123CopyOnWriteArrayList lst = new CopyOnWriteArrayList();ConcurrentModificationException cme = new ConcurrentModificationException();DefaultServiceUnavailableRetryStrategy strategy = new DefaultServiceUnavailableRetryStrategy(); 引入 var 保留类型后，我们可以将代码简化为这样： 123var lst = new CopyOnWriteArrayList();var cme = new ConcurrentModificationException();var strategy = new DefaultServiceUnavailableRetryStrategy(); &emsp;&emsp;由于变量的具体类型依赖编译器的推断，那么其明显的缺点掩盖了类型，特别是对于变量是某个方法的返回值的情况，如果不去看返回结果类型，那么不能清楚变量的具体类型。如下所示： 12var path = Paths.get(fileName); // infers Pathvar bytes = Files.readAllBytes(path); // infers bytes[] 因此，在编码定义变量的时候，一定需要定义可读性较强的变量名来避免使用var保留类型后，可读性降低的问题。]]></content>
      <categories>
        <category>IT技术</category>
        <category>Java</category>
        <category>从Java 8 到Java 11</category>
      </categories>
      <tags>
        <tag>IT技术</tag>
        <tag>Java</tag>
        <tag>新特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 11 新特性预览]]></title>
    <url>%2F2018%2F09%2F29%2F1%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;2018年是Java新版本发布比较频繁的一年，距2018年3月发布 Java 10 版本6个月后，Oracle发布了Java 11(18.9) (JSR 384)。值得注意的是，和Java 9 和 Java 10 这两个被称为“功能性的版本”不同（两者均只提供半年的技术支持），Java 11 不仅提供了长期支持服务，还将作为 Java 平台的参考实现。Oracle直到2023年9月都会为 Java 11 提供技术支持，而补丁和安全警告等扩展支持将持续到2026年。新的长期支持版本每三年发布一次，根据后续的发布计划，下一个长期支持版 Java 17 将于2021年发布。&emsp;&emsp;Java Development Kit（JDK）11 （下载） 不仅仅是一个升级版。 它是 Java 语言的一个大有改善的版本，其中有几个功能专注于性能。 下面将简单介绍其值得关注的一些新特性。 语法Lambda 参数的本地变量语法&emsp;&emsp;Lambda 参数的本地变量语法（JEP 323: Local-Variable Syntax for Lambda Parameters）：在声明隐式类型的 lambda 表达式的形式参数时允许使用 var。&emsp;&emsp;为了Java代码更加的简介，Java 10 引入了局部变量类型推断的特性，Java 11对该特性进行了增强，它允许在lamdba表达式中，声明隐式类型参数时使用var保留类型。这样保证了在Java 代码编写时，参数声明方式的一致性。代码如下所示： 12(x, y) -&gt; x.process(y) //before Java 11(var x, var y) -&gt; x.process(y) //Java 11 类库HTTP 客户端（标准）&emsp;&emsp;HTTP 客户端（标准）（JEP 321: HTTP Client (Standard)）：通过 JEP 110 标准化 JDK 9 中引入的孵化 HTTP 客户端 API，并在 JDK 10 中进行更新。&emsp;&emsp;新版本的HTTP客户端（java.net.http包中） 除了实现了HTTP(1.1和2)、WebSocket，同步和异步调用以及Reactive Streams，还提供了清晰易懂的 Fluent 界面。代码如下所示： 12345678//同步请求var request = HttpRequest.newBuilder() .uri(URI.create("https://snowolf.gitee.io")) .GET() .build();var client = HttpClient.newHttpClient();HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());System.out.println(response.body()); 12345678//异步请求var request = HttpRequest.newBuilder() .uri(URI.create("https://snowolf.gitee.io")) .build();var client = HttpClient.newHttpClient();client.sendAsync(request, HttpResponse.BodyHandlers.ofString()) .thenApply(HttpResponse::body) .thenAccept(System.out::println); Unicode 10&emsp;&emsp;Unicode 10（JEP 327: Unicode 10）：升级现有平台 API 以支持Unicode v10.0 标准。&emsp;&emsp;Unicode 10.0 增加了8518 个字符, 总计达到了136,690个字符。并且增加了4个脚本, 总结139个脚本, 同时还有56个新的emoji表情符号。Java 11 主要升级了如下类库，来支持Unicode V10.0标准。 java.lang包中的Character和String类 java.awt.font包中的NumericShaper类 java.text包中的Bidi、BreakIterator和Normalizerl类 移除 Java EE 和 CORBA 模块&emsp;&emsp;移除 Java EE 和 CORBA 模块（JEP 320: Remove the Java EE and CORBA Modules）：从Java SE Platform和JDK中删除Java EE和CORBA模块（JavaFX 也已被移除）。这些模块在Java SE 9中已弃用，声明的目的是为了在将来的版本中删除它们。&emsp;&emsp;Java 11主要删除了如下包： java.xml.ws (JAX-WS以及与之相关的SAAJ和Web Services元数据) java.xml.bind (JAXB) java.activation (JAF) java.xml.ws.annotation (Common Annotations) java.corba (CORBA) java.transaction (JTA) 同时移除了与之关联的模块，如下： java.se.ee (上述六个包的聚合模块) jdk.xml.ws (JAX-WS工具) jdk.xml.bind (JAXB工具) 弃用 Nashorn JavaScript 引擎&emsp;&emsp;弃用 Nashorn JavaScript 引擎（JEP 335: Deprecate the Nashorn JavaScript Engine）：弃用 Nashorn JavaScript 脚本引擎和 API 以及 jjs 工具，意图在将来的版本中删除它们。 &emsp;&emsp;Java 11 将如下两个模块标记为了过期（@Deprecated(forRemoval=true)）: jdk.scripting.nashorn（含jdk.nashorn.api.scripting和jdk.nashorn.api.tree两个包） jdk.scripting.nashorn.shell（含jjsg工具，再执行jjs命令，将会出现过期的警告提示。） 弃用 Pack200 工具和 API&emsp;&emsp;弃用 Pack200 工具和 API（JEP 336: Deprecate the Pack200 Tools and API）：在 java.util.jar 中弃用 pack200 和 unpack200 工具以及 Pack200 API。&emsp;&emsp;Pack200是当初Sun公司为更快地在网络上传输JAR文件而在JSR 200中提出的一种HTTP压缩方式。 从Sun JDK 1.50版就开始提供的Pack200压缩工具以及Pack200压缩文件。但随着技术的发展，开发人员已经不再需要使用这种压缩技术。主要理由如下： JDK 9为Java运行时（JEP 220）和用于构建运行时（JMOD）的模块引入了新的压缩方案。因此，JDK 9及更高版本不依赖Pack200; JDK 8是在构建时使用pack200压缩的最后一个版本，在安装时未使用unpack200解压缩。JDK本身已不再需要Pack200技术。 客户端应用程序（Applet）的格局已发生变化，大多数浏览器都不再支持插件。Applet不再需要Pack200压缩技术。 Pack200是一项复杂而精细的技术。文件与类文件格式和JAR文件格式紧密耦合，然而JEP 309在类文件格式中添加了一种新的常量池条目，并且JEP 238将版本控制元数据添加到JAR文件格式。java.util.jar.Pack200中的API对Java SE平台的模块化是有害的，导致在Java SE 9中删除了它的四种方法。总的来说，维护Pack200的成本是巨大的，并且超过了它的好处。包括它在Java SE和JDK中。 &emsp;&emsp;Java 11 将java.base模块中的如下三个类标记为过期（@Deprecated(forRemoval=true)）: java.util.jar.Pack200 java.util.jar.Pack200.Packer java.util.jar.Pack200.Unpacker 虚拟机基于巢的访问控制&emsp;&emsp;基于巢的访问控制（JEP 181:Nest-Based Access Control）：即“Nestmate”。巢是一种访问控制上下文，与 Java 编程语言中现有的嵌套类型概念一致。 巢允许逻辑上属于同一代码实体，但被编译为不同类文件的类，无需编译器插入可访问性扩展桥接方法，即可访问彼此的私有成员。&emsp;&emsp;Java 11 的巢访问控制引入了“巢（nest）”的概念，同一巢的两个成员（外部类和内部类）是同窝，它们具备同等的访问权限。这就改变了从Java 1.0开始的访问桥(access bridge) 的模式，改善了程序大小和额外性能损耗等问题，让应用程序和字节码更加简单、安全，并对开发者透明。 动态类文件常量&emsp;&emsp;动态类文件常量（JEP 309: Dynamic Class-File Constants）：扩展 Java 类文件格式以支持新的常量池形式，CONSTANT_Dynamic。 加载 CONSTANT_Dynamic 会将创建委托给 bootstrap 方法，就像链接 invokedynamic 调用站点将链接委托给 bootstrap 方法一样。降低开发新形式的可实现类文件约束带来的成本和干扰。 改进 Aarch64 内联函数&emsp;&emsp;改进 Aarch64 内联函数（JEP 315: Improve Aarch64 Intrinsics）：改进现有的字符串和数组内联函数，并在 AArch64 处理器上为 java.lang.Math sin，cos 和 log 函数实现新的内联函数。专用的CPU架构的代码模式可提高用户应用程序和基准测试的性能。 Epsilon 垃圾回收器&emsp;&emsp;Epsilon 垃圾回收器（JEP 318: Epsilon: A No-Op Garbage Collector (Experimental)）：又被称为”No-Op（无操作）”回收器,它仅负责内存分配，却没有实现任何实际的内存回收机制。 一旦可用的 Java 堆耗尽，JVM 将关闭。&emsp;&emsp;Epsilon 垃圾回收器主要用来进行性能测试、内存压力测试等，Epsilon GC可以作为度量其他垃圾回收器性能的对照组。大神Martijn说，Epsilon GC至少能够帮助理解GC的接口，有助于成就一个更加模块化的JVM。 运行记录仪&emsp;&emsp;运行记录仪（JEP 328: Flight Recorder）：提供低开销的数据收集框架，用于对 Java 应用程序和 HotSpot JVM 进行故障排除。&emsp;&emsp;JFR 是一套集成进入 JDK、JVM 内部的事件机制框架，通过良好架构和设计的框架，硬件层面的极致优化，生产环境的广泛验证，它可以做到极致的可靠和低开销。在SPECjbb2015等基准测试中，JFR 的性能开销最大不超过 1%，所以，工程师可以基本没有心理负担地在大规模分布式的生产系统使用，这意味着，我们既可以随时主动开启 JFR 进行特定诊断，也可以让系统长期运行 JFR，用以在复杂环境中进行“After-the-fact”分析。 启动单文件源代码程序&emsp;&emsp;启动单文件源代码程序（JEP 330: Launch Single-File Source-Code Programs）：增强 java 启动程序以运行作为 Java 源代码的单个文件提供的程序，包括通过“shebang”文件和相关技术从脚本中使用。&emsp;&emsp;单文件程序是指整个程序只有一个源码文件，通常是早期学习Java阶段，或者写一个小型工具类。以HelloWorld.java为例，运行它之前需要先编译。我们希望Java启动器能直接运行这个源码级的程序： 1java HelloWorld.java 低开销的堆分配采样方法&emsp;&emsp;低开销的堆分配采样方法（JEP 331: Low-Overhead Heap Profiling）：提供一种低开销的 Java 堆分配采样方法，可通过 JVMTI 访问。&emsp;&emsp;我们知道，高效地了解在 Java 堆上都进行了哪些对象分配，是诊断内存问题的基本出发点之一。 JEP 331 来源于 Google 等业界前沿厂商的一线实践，通过获取对象分配的 Call-site，为 JDK 补足了对象分配诊断方面的一些短板，工程师可以通过 JVMTI 使用这个能力增强自身的工具。 ZGC：可扩展的低延迟垃圾收集器&emsp;&emsp;ZGC：可扩展的低延迟垃圾收集器（JEP 333: ZGC: A Scalable Low-Latency Garbage Collector (Experimental)）：Z垃圾收集器，也称为 ZGC，是一个可扩展的低延迟垃圾收集器。&emsp;&emsp;从 JVM GC 的角度，JDK 11 引入了两种新的 GC，其中包括也许是划时代意义的 ZGC，虽然其目前还是实验特性，但是从能力上来看，这是 OpenJDK 的一个巨大突破，为特定生产环境的苛刻需求提供了一个可能的选择。例如，对部分企业核心存储等产品，如果能够保证不超过 10ms 的 GC 暂停，可靠性会上一个大的台阶，这是过去我们进行 GC 调优几乎做不到的，是能与不能的问题。 安全采用 Curve25519 和 Curve448 算法实现的密钥协议&emsp;&emsp;采用 Curve25519 和 Curve448 算法实现的密钥协议（JEP 324: Key Agreement with Curve25519 and Curve448）：使用RFC 7748 中描述的 Curve25519 和 Curve448 实现密钥协议。&emsp;&emsp;密码学要求使用 Curve25519 和Curve448 是因为它们的安全性和性能。JDK会增加两个新的接口XECPublicKey 和 XECPrivateKey，示例代码如下： 123456789101112131415KeyPairGenerator kpg = KeyPairGenerator.getInstance("XDH");NamedParameterSpec paramSpec = new NamedParameterSpec("X25519");kpg.initialize(paramSpec); // equivalent to kpg.initialize(255)// alternatively: kpg = KeyPairGenerator.getInstance("X25519")KeyPair kp = kpg.generateKeyPair();KeyFactory kf = KeyFactory.getInstance("XDH");BigInteger u = ...XECPublicKeySpec pubSpec = new XECPublicKeySpec(paramSpec, u);PublicKey pubKey = kf.generatePublic(pubSpec);KeyAgreement ka = KeyAgreement.getInstance("XDH");ka.init(kp.getPrivate());ka.doPhase(pubKey, true);byte[] secret = ka.generateSecret(); 实现 ChaCha20 和 Poly1305 加密算法&emsp;&emsp;实现 ChaCha20 和 Poly1305 加密算法（JEP 329: ChaCha20 and Poly1305 Cryptographic Algorithms）：实现RFC 7539中指定的 ChaCha20 和 ChaCha20-Poly1305 密码。ChaCha20 是一种相对较新的流密码，可以替代旧的、不安全的 RC4 流密码。基于ChaCha20加密算法的示例代码： 123456789// Get a Cipher instance and set up the parameters// Assume SecretKey "key", 12-byte nonce "nonceBytes" and plaintext "pText"// are coming from outside this code snippetCipher mambo = Cipher.getInstance("ChaCha20");ChaCha20ParameterSpec mamboSpec = new ChaCha20ParameterSpec(nonceBytes, 7); // Use a starting counter value of "7"// Encrypt our inputmambo.init(Cipher.ENCRYPT_MODE, key, mamboSpec);byte[] encryptedResult = mambo.doFinal(pText); 基于ChaCha20-Poly1305加密算法的示例代码： 12345678910// Get a Cipher instance and set up the parameters// Assume SecretKey "key", 12-byte nonce "nonceBytes" and plaintext "pText"// are coming from outside this code snippetCipher mambo = Cipher.getInstance("ChaCha20-Poly1305");AlgorithmParameterSpec mamboSpec = new IvParameterSpec(nonceBytes);// Encrypt our inputmambo.init(Cipher.ENCRYPT_MODE, key, mamboSpec);byte[] encryptedResult = new byte[mambo.getOutputSize(pText.length)];mambo.doFinal(pText, 0, pText.length, encryptedResult); 传输层安全性（TLS）1.3&emsp;&emsp;传输层安全性（TLS）1.3（JEP 332: Transport Layer Security (TLS) 1.3）：实现传输层安全性（TLS）协议RFC 8446 的 1.3 版。&emsp;&emsp;TLS 1.3是TLS协议的重大改进，与以前的版本相比，它提供了显着的安全性和性能改进。其他供应商的几个早期实现已经可用。我们需要支持TLS 1.3以保持竞争力并与最新标准保持同步。这个特性的实现动机和Unicode 10一样，也是紧跟历史潮流。 &emsp;&emsp;以上就是Java 11的主要新特性，如果想详细了解这些新特性对开发带来的帮助和使用方法，请持续关注本系列博客。]]></content>
      <categories>
        <category>IT技术</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IT技术</tag>
        <tag>Java</tag>
        <tag>新特性</tag>
      </tags>
  </entry>
</search>
