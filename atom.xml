<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>焰冰封</title>
  
  <subtitle>个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://snowolf.gitee.io/"/>
  <updated>2019-01-04T06:57:45.084Z</updated>
  <id>https://snowolf.gitee.io/</id>
  
  <author>
    <name>Snowolf Lee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从Java 8 到Java 11 （语言篇）：二、Java的Http客户端</title>
    <link href="https://snowolf.gitee.io/2018/10/03/1/"/>
    <id>https://snowolf.gitee.io/2018/10/03/1/</id>
    <published>2018-10-03T02:53:15.000Z</published>
    <updated>2019-01-04T06:57:45.084Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;在 Java SE 9 中，Oracle 公司将发布新的 HTTP 2 Client API 来支持 HTTP/2 协议和 WebSocket 特性。现有的 HTTP Client API 存在很多问题（如支持 HTTP/1.1 协议但是不支持 HTTP/2 协议和 WebSocket，仅仅作用在 Blocking 模式中，并存在大量性能问题），他们正在被使用新的 HTTP 客户端的 HttpURLConnection API 所替代。</p><p>&emsp;&emsp;Oracle 公司在 “java.net.http” 模块下引入新的 HTTP 2 Client API。它将同时支持 HTTP/1.1 和 HTTP/2 协议，也同时支持同步（Blocking Mode）和异步模式，支持 WebSocket API 使用中的异步模式。</p><h2 id="什么是HTTP-2"><a href="#什么是HTTP-2" class="headerlink" title="什么是HTTP/2"></a>什么是HTTP/2</h2><p>&emsp;&emsp;HTTP/1.1是当前web应用使用最广泛和最成功的协议之一。在过去的16年中，HTTP/1.1对于互联网的发展是有利的，但是协议的细微问题已经开始出现。例如，资源密集型的Web应用程序有较大的减速的可能性，因为HTTP/1.1每个TCP连接只允许一个未完成的请求。</p><p>&emsp;&emsp;HTTP/2是HTTP/1.1规范的替代品。尽管它是一个替代品，核心功能，状态代码等仍然是一样的。因此，这不是现有HTTP/1.1规范的完整返工。通过HTTP/2，IETF HTTP工作组旨在提供更优化的协议版本，具有更好的最终用户隐私，客户端和源资源分配。</p><p>&emsp;&emsp;HTTP/2 可以让我们的应用更快、更简单、更稳定。其目的是通过支持完整的请求与响应复用来减少延迟，通过有效压缩 HTTP 标头字段将协议开销降至最低，同时增加对请求优先级和服务器推送的支持。为达成这些目标，HTTP/2 还给我们带来了大量其他协议层面的辅助实现，例如新的流控制、错误处理和升级机制。</p><p>&emsp;&emsp;HTTP/2 没有改动 HTTP 的应用语义。HTTP 方法、状态代码、URI 和标头字段等核心概念一如往常。不过，HTTP/2 修改了数据格式化（分帧）以及在客户端与服务器间传输的方式。这两点统帅全局，通过新的分帧层向我们的应用隐藏了所有复杂性。因此，所有现有的应用都可以不必修改而在新协议下运行。<br><img src="/images/blog/jdk8_to_jdk11_changes/03_JDK_HTTP_Client/binary_framing_layer01.svg" alt="分帧层"></p><h2 id="Http客户端API基本使用"><a href="#Http客户端API基本使用" class="headerlink" title="Http客户端API基本使用"></a>Http客户端API基本使用</h2><p>&emsp;&emsp;直到Java 1.8，Java只提供了对HTTP/1.1的支持。因此，一些Java开发人员不得不依赖其他客户端，如Jetty的ALPN（Application Layer Protocol Negotiation，应用层协议协商）来编写与支持HTTP/2协议的服务器进行交互的客户端代码。为了方便开发人员使用统一的Http客户端，2014年，创建了JDK增强建议（<a href="http://openjdk.java.net/jeps/110" target="_blank" rel="noopener">JEP 110</a>）,定义实现HTTP/2和WebSockets的新HTTP客户端API，该增强建议中的内容在Java SE 9中得到了体现。在Java SE 10中，通过<a href="http://openjdk.java.net/jeps/321" target="_blank" rel="noopener">JEP 321</a>, 对Http 客户端API进行了增强，新版本的HTTP客户端（java.net.http模块） 除了实现了HTTP(1.1和2)、WebSocket，同步和异步调用以及Reactive Streams，还提供了清晰易懂的流式API。</p><h3 id="引入Http客户端模块"><a href="#引入Http客户端模块" class="headerlink" title="引入Http客户端模块"></a>引入Http客户端模块</h3><p>&emsp;&emsp;Java SE 9引入了模块系统，在之后的版本，需要使用其他模块时，需要在模块什么中指定其所依赖的模块。在使用Http客户端的时候，需要先在模块声明中引入该模块。如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> com.snowolf.tutorial &#123;</span><br><span class="line">    <span class="keyword">requires</span> java.net.http;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建HTTP客户端"><a href="#创建HTTP客户端" class="headerlink" title="创建HTTP客户端"></a>创建HTTP客户端</h3><p>&emsp;&emsp;创建HTTP客户端需要使用HttpClient抽象类，它提供了两种方法创建HttpClient对象：</p><ul><li>使用HttpClient类的newHttpClient()静态方法</li></ul><p>&emsp;&emsp;这种方式创建的HttpClient对象默认使用的HTTP协议版本是1.1，如果需要创建2.0版本的，需要使用其他的API。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var client = HttpClient.newHttpClient();</span><br></pre></td></tr></table></figure><ul><li>使用HttpClient.Builder类的build()方法</li></ul><p>&emsp;&emsp;可以使用HttpClient.newBuilder()静态方法，创建一个新的HttpClient.Builder类实例。 HttpClient.Builder类提供了一些列配置方法，而且支持链式调用，只需要在最后调用返回HttpClient对象的build()方法，就可以创建一个HttpClient对象。 以下语句创建一个HttpClient，重定向策略设置为ALWAYS，HTTP版本设置为2.0：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var client = HttpClient.newBuilder()</span><br><span class="line">                    .version(Version.HTTP_2)   <span class="comment">//指定HTTP协议版本</span></span><br><span class="line">                    .followRedirects(Redirect.ALWAYS) <span class="comment">//指定重定向策略</span></span><br><span class="line">                    .build();</span><br></pre></td></tr></table></figure><h3 id="创建HTTP请求"><a href="#创建HTTP请求" class="headerlink" title="创建HTTP请求"></a>创建HTTP请求</h3><p>&emsp;&emsp; HTTP/2 仍是对之前 HTTP 标准的扩展，而非替代。 HTTP 的应用语义不变，提供的功能不变，HTTP 方法、状态代码、URI 和标头字段等这些核心概念也不变。这些方面的变化都不在 HTTP/2 考虑之列。对于用户来说，HTTP/2的请求所需要的包含的内容与HTTP 1.1是一样的，它们同样是请求方法、URI、请求头以及请求体这些内容。如下图：<br><img src="/images/blog/jdk8_to_jdk11_changes/03_JDK_HTTP_Client/02.png" alt="HTTP请求"></p><p>&emsp;&emsp;这也就说明在创建HTTP请求时，只需要关心请求方法、URI、请求头（HttpHeaders）和请求体这些内容。创建HTTP请求需要使用HttpRequest抽象类，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var req = HttpRequest.newBuilder() <span class="comment">//创建HttpRequest.Builder</span></span><br><span class="line">             <span class="comment">//指定请求地址,也可以在newBuilder(URI.create("http://openjdk.java.net/"))时指定。</span></span><br><span class="line">            .uri(URI.create(<span class="string">"http://openjdk.java.net/"</span>)) </span><br><span class="line">            .header(<span class="string">"Accept"</span>, <span class="string">"text/html,*/*;q=0.8"</span>)  <span class="comment">//设置请求头</span></span><br><span class="line">            .timeout(Duration.ofMinutes(<span class="number">1</span>)) <span class="comment">//设置超时时长</span></span><br><span class="line">            .GET() <span class="comment">//指定请求方法</span></span><br><span class="line">            .build();</span><br></pre></td></tr></table></figure><h3 id="处理HTTP响应"><a href="#处理HTTP响应" class="headerlink" title="处理HTTP响应"></a>处理HTTP响应</h3><p>&emsp;&emsp;按照HTTP的规范，一般来说，其响应包含状态码，响应头和响应体组成。那么在处理响应的时候，也就是对这三个方面的数据进行处理。<br><img src="/images/blog/jdk8_to_jdk11_changes/03_JDK_HTTP_Client/03.png" alt="HTTP响应"></p><p>&emsp;&emsp;创建完成HttpRequest之后，可以使用HttpClient将请求发送到服务器，并同步或异步地接收响应。HttpResponse类的实例表示从服务器接收到的响应。可以通过其内部接口HttpResponse.BodyHandler的实现类来处理Http响应。HttpResponse.BodyHandlers提供了常用的响应处理方法。HttpResponse.BodyHandler会将处理的结果封装到HttpResponse对象中。</p><h3 id="发送HTTP请求"><a href="#发送HTTP请求" class="headerlink" title="发送HTTP请求"></a>发送HTTP请求</h3><p>&emsp;&emsp;Http客户端API支持发送同步和异步的请求，在Java SE 10中，HttpClient 既可以被同步使用，也可以被异步使用。同步请求将会阻塞当前的线程，直到返回响应消息。BodyHandlers 定义了响应消息体的类型（例如string，byte-array 或 file）。示例代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var response = client.send(request, HttpResponse.BodyHandlers.ofString()); <span class="comment">//同步请求</span></span><br><span class="line">System.out.println(response.statusCode()); <span class="comment">// 打印状态码</span></span><br><span class="line">response.headers().map()</span><br><span class="line">    .forEach((k,v) -&gt; System.out.println(k + <span class="string">": "</span> + v)); <span class="comment">// 打印响应头</span></span><br><span class="line">System.out.println(response.body()); <span class="comment">// 打印响应体</span></span><br></pre></td></tr></table></figure><p>同样的请求也可以被异步执行。调用 sendAsync 方法不会阻塞当前线程，并且会返回 CompletableFuture 对象，用来构建异步执行结果的操作流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var response = client.sendAsync(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">response.thenApply(HttpResponse::statusCode) <span class="comment">//打印状态码</span></span><br><span class="line">        .thenAccept(System.out::println);</span><br><span class="line">response.thenApply(HttpResponse::headers) <span class="comment">// 打印响应头</span></span><br><span class="line">        .thenAccept( headers -&gt; &#123;</span><br><span class="line">            headers.map().forEach((k,v) -&gt; System.out.println(k + <span class="string">": "</span> + v));</span><br><span class="line">        &#125;);</span><br><span class="line">response.thenApply(HttpResponse::body) <span class="comment">// 打印响应体</span></span><br><span class="line">        .thenAccept(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="基本请求认证"><a href="#基本请求认证" class="headerlink" title="基本请求认证"></a>基本请求认证</h3><p>&emsp;&emsp;HTTP API提供了一个Authenticator抽象类来描述HTTP认证信息。它提供不同的认证方案（例如，基本或摘要认证）。 在大多数情况下，身份验证需要用户名和密码才能连接到服务器，我们可以使用PasswordAuthentication类来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var client = HttpClient.newBuilder()</span><br><span class="line">            .authenticator(<span class="keyword">new</span> Authenticator() &#123; <span class="comment">// 指定认证的账号和密码</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> PasswordAuthentication <span class="title">getPasswordAuthentication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> PasswordAuthentication(<span class="string">"postman"</span>, <span class="string">"password"</span>.toCharArray());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).build();</span><br><span class="line">var request = HttpRequest.newBuilder(</span><br><span class="line">                URI.create(<span class="string">"https://postman-echo.com/basic-auth"</span>))</span><br><span class="line">            .build(); <span class="comment">// 创建HttpRequest.Builder</span></span><br><span class="line">var response = client.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">System.out.println(response.statusCode()); <span class="comment">// 200</span></span><br></pre></td></tr></table></figure><h3 id="使用代理"><a href="#使用代理" class="headerlink" title="使用代理"></a>使用代理</h3><p>&emsp;&emsp;HTTP API支持通过代理的方式访问网络，它提供了ProxySelector抽象类来设置代理对象。它提供默认提供操作系统的代理方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var client = HttpClient.newBuilder()</span><br><span class="line">                    .proxy(ProxySelector.getDefault()) <span class="comment">//设置代理服务器</span></span><br><span class="line">                    .build();</span><br><span class="line">var request = HttpRequest.newBuilder(</span><br><span class="line">                URI.create(<span class="string">"http://www.baidu.com"</span>))</span><br><span class="line">            .build(); <span class="comment">// 创建HttpRequest.Builder</span></span><br><span class="line">var response = client.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">System.out.println(response.statusCode()); <span class="comment">// 200</span></span><br></pre></td></tr></table></figure><h2 id="多路复用请求"><a href="#多路复用请求" class="headerlink" title="多路复用请求"></a>多路复用请求</h2><p>&emsp;&emsp;HTTP/2的多路复用技术解决了HTTP 1.1中文本串行传输和连接次数过多的问题，提高了网络效率。<br><img src="/images/blog/jdk8_to_jdk11_changes/03_JDK_HTTP_Client/04.png" alt="HTTP2"></p><p>&emsp;&emsp;多路复用允许同时通过单一的HTTP/2.0连接发起多重的请求-响应消息。在HTTP1.1协议中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量的限制，超过了这个限制的请求就会被阻塞。而多路复用允许同时通过单一的 HTTP2.0 连接发起多重的“请求-响应”消息。</p><p>&emsp;&emsp;HTTP2的请求的TCP的connection一旦建立，后续请求以stream的方式发送。每个stream的基本组成单位是frame（二进制帧）。客户端和服务器可以把 HTTP 消息分解为互不依赖的帧，然后乱序发送，最后再在另一端把它们重新组合起来。<br><img src="/images/blog/jdk8_to_jdk11_changes/03_JDK_HTTP_Client/05.png" alt="HTTP2多路复用"></p><p>&emsp;&emsp;HTTP客户端API支持HTTP/2的多路复用技术，当我们需要并行请求同一域名时，可以使用这样技术。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">var executor = Executors.newFixedThreadPool(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">var httpClient = HttpClient.newBuilder()</span><br><span class="line">                .version(Version.HTTP_2)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">var mainRequest = HttpRequest.newBuilder()</span><br><span class="line">                .uri(URI.create(<span class="string">"https://http2.akamai.com/demo/h2_demo_frame.html"</span>))</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">var mainResponse = httpClient.send(mainRequest, BodyHandlers.ofString());</span><br><span class="line"></span><br><span class="line">var futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// For each image resource in the main HTML, send a request on a separate thread</span></span><br><span class="line">mainResponse.body().lines()</span><br><span class="line">            .filter(line -&gt; line.trim().startsWith(<span class="string">"&lt;img height"</span>))</span><br><span class="line">            .map(line -&gt; line.substring(line.indexOf(<span class="string">"src='"</span>) + <span class="number">5</span>, line.indexOf(<span class="string">"'/&gt;"</span>)))</span><br><span class="line">            .forEach(image -&gt; &#123;</span><br><span class="line">                var imgFuture = executor.submit(() -&gt; &#123;</span><br><span class="line">                var imgRequest = HttpRequest.newBuilder()</span><br><span class="line">                                 .uri(URI.create(<span class="string">"https://http2.akamai.com"</span> + image))</span><br><span class="line">                                 .build();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var imageResponse = httpClient.send(imgRequest, BodyHandlers.ofString());</span><br><span class="line">                    System.out.println(<span class="string">"Loaded "</span> + image + <span class="string">", status code: "</span> + imageResponse.statusCode());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException | InterruptedException ex) &#123;</span><br><span class="line">                             System.err.println(<span class="string">"Error during image request for "</span> + image);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            futures.add(imgFuture);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for all submitted image loads to be completed</span></span><br><span class="line">futures.forEach(f -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        f.get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException ex) &#123;</span><br><span class="line">        System.err.println(<span class="string">"Error waiting for image load"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="请求头压缩"><a href="#请求头压缩" class="headerlink" title="请求头压缩"></a>请求头压缩</h2><p>&emsp;&emsp;HTTP/1.1的请求头带有大量信息，而且每次都要重复发送。HTTP1.1中的请求头是没有压缩的，gzip只会压缩请求体。一般轮询请求头，特别是cookie会占用很多的空间，请求头压缩会使得整个HTTP请求的数据表小很多，传输也就会更快。HTTP/2 为了减少这部分开销，采用了HPACK请求头压缩算法对头部进行压缩。<br><img src="/images/blog/jdk8_to_jdk11_changes/03_JDK_HTTP_Client/06.png" alt="头部压缩"></p><p>&emsp;&emsp;HTTP/2的HPACK请求头压缩算法是在服务器和客户端维护一个“请求头表”，表中用索引代码请求头名称，或者请求头键-值对，第一次发送两端都会记住已发送过哪些请求头，下一次发送只需要传输差异的数据，相同的数据直接用索引表示即可，另外还可以选择地对请求头压缩后再传输。按照这样的设计，两次轮询的请求头基本上是一样的，那之后的请求基本只需要发送几个索引即可。<br><img src="/images/blog/jdk8_to_jdk11_changes/03_JDK_HTTP_Client/07.png" alt="头部压缩"></p><p>&emsp;&emsp;“请求头表”有两种，一种是静态表，即HTTP/2协议内置了常用的一些请求头名和请求头键值对。另一种是动态表，保存自定义的请求头或五花八门的键值对等，动态表可以通过SETTINGS帧的SETTINGS_HEADER_TABLE_SIZE规定大小。</p><p>&emsp;&emsp;在Java 10 中这种请求头压缩算法在“java.net.http” 模块中的“jdk.internal.net.http.hpack”包中实现。</p><h2 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h2><p>&emsp;&emsp;以前，我们通过浏览器基于HTTP/1.1访问网页的时候，服务会将HTML页面作为响应发送给客户端，客户端需要解析这个HTML页面，并重新请求这个页面中嵌入的JavaScript，图片和CSS。HTTP/2的服务器推送允许服务器主动将资源发送到客户端的缓存以供将来使用。服务器可以在建立流后立即开始发送，而无需等待客户端请求它们。例如，可以通过返回所请求的网页来并行地将诸如包含图像的资源推送到客户端。因此，浏览优化（如图像精灵或资源内联）不再有用。所以说，HTTP/2 服务器推送是一种提升首屏加载速度的技术，它允许 Web 服务器在收到浏览器的请求之前提前发送一些资源给客户端。</p><p>&emsp;&emsp;值得注意的是，HTTP/2推送并不是要替换随HTML5引入的服务器发送事件或WebSocket。这些HTML5服务器推送技术脱离了HTTP的严格请求-响应语义，这意味着客户端发送HTTP请求并等待直到收到HTTP响应。服务器发送的事件和WebSockets允许服务器在没有先前的HTTP请求的情况下随时发送事件或数据。</p><p>&emsp;&emsp;HTTP/2推送是不同的，因为它仍然基于请求-响应语义。但HTTP/2推送允许服务器响应数据以获得比客户端请求更多的查询。通过发送PUSH_PROMISE帧，服务器将启动推送。 PUSH_PROMISE帧包括用于推送的HTTP响应消息的关联HTTP请求消息数据。例如，PUSH_PROMISE帧包括请求URI或请求方法。PUSH_PROMISE帧之后是HEADER和DATA帧，以将HTTP响应消息进行推送。<br><img src="/images/blog/jdk8_to_jdk11_changes/03_JDK_HTTP_Client/08.jpg" alt="服务器推送"></p><p>&emsp;&emsp;HTTP/2的客户端提供了HttpResponse.PushPromiseHandler接口来处理服务器端推送。</p>]]></content>
    
    <summary type="html">
    
      Java 9引入了一个新的孵化HttpClient API来处理HTTP请求。从Java 11开始，这个API已经可以在标准库 java.net 中使用了。这个新的 HttpClient 既可以被同步使用，也可以被异步使用。本文将以最新的Java 11 为标准，详细介绍HttpClient API的主要功能以及使用方式。
    
    </summary>
    
      <category term="IT技术" scheme="https://snowolf.gitee.io/categories/IT%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://snowolf.gitee.io/categories/IT%E6%8A%80%E6%9C%AF/Java/"/>
    
      <category term="从Java 8 到Java 11" scheme="https://snowolf.gitee.io/categories/IT%E6%8A%80%E6%9C%AF/Java/%E4%BB%8EJava-8-%E5%88%B0Java-11/"/>
    
    
      <category term="IT技术" scheme="https://snowolf.gitee.io/tags/IT%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://snowolf.gitee.io/tags/Java/"/>
    
      <category term="新特性" scheme="https://snowolf.gitee.io/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>从Java 8 到Java 11 （语言篇）：一、局部变量类型接口</title>
    <link href="https://snowolf.gitee.io/2018/09/30/1/"/>
    <id>https://snowolf.gitee.io/2018/09/30/1/</id>
    <published>2018-09-30T02:53:15.000Z</published>
    <updated>2018-10-11T06:29:25.949Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;局部变量类型接口是Java 10 为了提高代码的可读性而增加的一个语法糖。从<a href="https://www.surveymonkey.com/results/SM-FLWGS5PW/" target="_blank" rel="noopener">网络调查</a>的数据来看，这个新特性得到了广大开发者（74%）的认可。现在我们可以使用 var 替换局部变量声明时的类型部分，从而避免耗费精力去写出那些显而易见的类型。<br><img src="/images/blog/jdk8_to_jdk11_changes/02_Local_Variable_Type_Inference/01.png" alt="统计数据"></p><h2 id="什么是局部变量类型接口"><a href="#什么是局部变量类型接口" class="headerlink" title="什么是局部变量类型接口"></a>什么是局部变量类型接口</h2><p>&emsp;&emsp;Java 10 采用了一个叫做 var 的保留类型来实现局部变量推断。在Java 10 之前，我们在定义局部变量的时候，必须要指定变量的具体类型:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String text = <span class="string">"Hello Java 9"</span>;</span><br></pre></td></tr></table></figure><p>现在，可以使用var来代替具体的类型String。编译器将会根据上下文自动推断出变量的具体类型，那么上述代码可以修改为如下形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var text = <span class="string">"Hello Java 10"</span>;</span><br></pre></td></tr></table></figure><p>值得特别注意的是，为了兼容旧版本，var 不是关键字，而是一个保留类型，也就意味着你仍然可以像这样用 var 为你的变量和函数命名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String var = <span class="string">"Hello Java"</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;与JavaScript等动态语言不同的是，Java中的 var 声明的变量仍旧是静态类型。你不能再次赋予另一个与原类型不符的变量值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var text  = <span class="string">"Hello Java 10"</span>;</span><br><span class="line">text = <span class="number">10</span>; <span class="comment">// Error：Type mismatch: cannot convert from int to String</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;遗憾的是，Java 10 没有引入 Scala 和 Kotlin 中用于声明不可变变量的 val 关键字，而需要使用 final var 这种遗憾的语法来达到这个目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> var text  = <span class="string">"Hello Java 10"</span>;</span><br><span class="line">text = <span class="string">"Hello Java 11"</span>; <span class="comment">// Error：The final local variable text cannot be assigned. It must be blank and not using a compound assignment</span></span><br></pre></td></tr></table></figure><h2 id="局部变量类型接口的适用范围"><a href="#局部变量类型接口的适用范围" class="headerlink" title="局部变量类型接口的适用范围"></a>局部变量类型接口的适用范围</h2><p>&emsp;&emsp;var 保留类型可以在定义如下类型的变量的时候使用。</p><ol><li>字面量定义局部变量</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var list = <span class="keyword">new</span> ArrayList&lt;String&gt;();    <span class="comment">// infers ArrayList&lt;String&gt;</span></span><br><span class="line">var lst = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">var text = <span class="string">"Hello Java 10"</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>接收方法返回值定义局部变量</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var stream = list.stream();            <span class="comment">// infers Stream&lt;String&gt;</span></span><br><span class="line">var path = Paths.get(fileName);        <span class="comment">// infers Path</span></span><br><span class="line">var bytes = Files.readAllBytes(path);  <span class="comment">// infers bytes[]</span></span><br></pre></td></tr></table></figure><ol start="3"><li>循环中定义局部变量</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; lst = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line"><span class="keyword">for</span> (var element : lst) &#123;...&#125;  <span class="comment">// infers String</span></span><br><span class="line"><span class="keyword">for</span> (var counter = <span class="number">0</span>; counter &lt; lst.size(); counter++)  &#123;...&#125;   <span class="comment">// infers int</span></span><br></pre></td></tr></table></figure><ol start="4"><li>try-with-resources中定义的变量</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (var input =</span><br><span class="line">     <span class="keyword">new</span> FileInputStream(<span class="string">"validation.txt"</span>)) &#123;...&#125;   <span class="comment">// infers FileInputStream</span></span><br></pre></td></tr></table></figure><ol start="5"><li>Lambda 表达式</li></ol><p>&emsp;&emsp;这是Java 11 对var 保留类型的增强，为了代码的一致性，它允许在lamdba表达式中，声明隐式类型参数时使用var保留类型。例如，在Java 11之前，lamdba表达式需要只能这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BiFunction&lt;Integer, Integer, Integer&gt; fnc = (a, b) -&gt; a + b;</span><br></pre></td></tr></table></figure><p>在 Java 11 和之后的版本，可以改写成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BiFunction&lt;Integer, Integer, Integer&gt; fnc = (var a,var b) -&gt; a + b;</span><br></pre></td></tr></table></figure><p>需要注意的是，它不允许对lamdba表达式中的参数只有部分指定var保留类型，或者混合使用保留关键字和其他类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fnc = (var a, b) -&gt; a + b; <span class="comment">//ERROR: Syntax error on token "var"</span></span><br><span class="line">fnc = (var a, <span class="keyword">int</span> b) -&gt; a + b; <span class="comment">//ERROR: 'var' cannot be mixed with non-var parameters</span></span><br></pre></td></tr></table></figure><h2 id="局部变量类型接口的实现原理"><a href="#局部变量类型接口的实现原理" class="headerlink" title="局部变量类型接口的实现原理"></a>局部变量类型接口的实现原理</h2><p>&emsp;&emsp;var其实就是 Java 10 增加的一种语法糖而已，在编译期间会自动推断实际类型，其编译后的字节码和实际类型一致，如以下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String var = <span class="string">"Hello Java"</span>;</span><br><span class="line">    var text  = <span class="string">"Hello Java 10"</span>;</span><br><span class="line">    System.out.println(var + <span class="string">"\n"</span> + text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其编译后的字节码如下：</p><figure class="highlight java"><figcaption><span>mark:3,5</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">  Code:</span><br><span class="line">     0: ldc           #16                 // String Hello Java</span><br><span class="line">     <span class="number">2</span>: astore_1</span><br><span class="line">     3: ldc           #18                 // String Hello Java 10</span><br><span class="line">     <span class="number">5</span>: astore_2</span><br><span class="line">     6: getstatic     #20                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">     9: new           #26                 // class java/lang/StringBuilder</span><br><span class="line">    <span class="number">12</span>: dup</span><br><span class="line">    <span class="number">13</span>: aload_1</span><br><span class="line">    14: invokestatic  #28                 // Method java/lang/String.valueOf:(Ljava/lang/Object;)Ljava/lang/String;</span><br><span class="line">    17: invokespecial #34                 // Method java/lang/StringBuilder."&lt;init&gt;":(Ljava/lang/String;)V</span><br><span class="line">    20: ldc           #37                 // String \n</span><br><span class="line">    22: invokevirtual #39                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">    <span class="number">25</span>: aload_2</span><br><span class="line">    26: invokevirtual #39                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">    29: invokevirtual #43                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">    32: invokevirtual #47                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">    <span class="number">35</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>从上述代码的第3和5行可以看出，在编译后，虚拟机识别的仍是具体类型，而不是var类型。</p><h2 id="局部变量类型接口的优缺点"><a href="#局部变量类型接口的优缺点" class="headerlink" title="局部变量类型接口的优缺点"></a>局部变量类型接口的优缺点</h2><p>&emsp;&emsp;局部变量类型接口的引入，其最大的好处是简化了代码，增强了代码的可读性，让Java代码更加简洁。例如，在Java 10 之前，一般代码会写成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CopyOnWriteArrayList lst = <span class="keyword">new</span> CopyOnWriteArrayList();</span><br><span class="line">ConcurrentModificationException cme = <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">DefaultServiceUnavailableRetryStrategy strategy = <span class="keyword">new</span> DefaultServiceUnavailableRetryStrategy();</span><br></pre></td></tr></table></figure><p>引入 var 保留类型后，我们可以将代码简化为这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var lst = <span class="keyword">new</span> CopyOnWriteArrayList();</span><br><span class="line">var cme = <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">var strategy = <span class="keyword">new</span> DefaultServiceUnavailableRetryStrategy();</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;由于变量的具体类型依赖编译器的推断，那么其明显的缺点掩盖了类型，特别是对于变量是某个方法的返回值的情况，如果不去看返回结果类型，那么不能清楚变量的具体类型。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var path = Paths.get(fileName);        <span class="comment">// infers Path</span></span><br><span class="line">var bytes = Files.readAllBytes(path);  <span class="comment">// infers bytes[]</span></span><br></pre></td></tr></table></figure><p>因此，在编码定义变量的时候，一定需要定义可读性较强的变量名来避免使用var保留类型后，可读性降低的问题。</p>]]></content>
    
    <summary type="html">
    
      局部变量类型接口是Java 10 为了提高代码的可读性而增加的一个语法糖。它利用类型自动推断，将非null初始化的局部变量可以使用var的保留类型进行定义。那么在实际代码中应该怎样去使用呢？又需要注意什么问题？本文将就上述问题进行详尽的分析。
    
    </summary>
    
      <category term="IT技术" scheme="https://snowolf.gitee.io/categories/IT%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://snowolf.gitee.io/categories/IT%E6%8A%80%E6%9C%AF/Java/"/>
    
      <category term="从Java 8 到Java 11" scheme="https://snowolf.gitee.io/categories/IT%E6%8A%80%E6%9C%AF/Java/%E4%BB%8EJava-8-%E5%88%B0Java-11/"/>
    
    
      <category term="IT技术" scheme="https://snowolf.gitee.io/tags/IT%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://snowolf.gitee.io/tags/Java/"/>
    
      <category term="新特性" scheme="https://snowolf.gitee.io/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Java 11 新特性预览</title>
    <link href="https://snowolf.gitee.io/2018/09/29/1/"/>
    <id>https://snowolf.gitee.io/2018/09/29/1/</id>
    <published>2018-09-29T04:19:19.000Z</published>
    <updated>2018-10-12T04:48:07.931Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;2018年是Java新版本发布比较频繁的一年，距2018年3月发布 Java 10 版本6个月后，Oracle发布了Java 11(18.9) (<a href="http://cr.openjdk.java.net/~iris/se/11/latestSpec/" target="_blank" rel="noopener">JSR 384</a>)。值得注意的是，和Java 9 和 Java 10 这两个被称为“功能性的版本”不同（两者均只提供半年的技术支持），Java 11 不仅提供了长期支持服务，还将作为 Java 平台的参考实现。Oracle直到2023年9月都会为 Java 11 提供技术支持，而补丁和安全警告等扩展支持将持续到2026年。新的长期支持版本每三年发布一次，根据后续的发布计划，下一个长期支持版 Java 17 将于2021年发布。</p><p>&emsp;&emsp;Java Development Kit（JDK）11 （<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk11-downloads-5066655.html" target="_blank" rel="noopener">下载</a>） 不仅仅是一个升级版。 它是 Java 语言的一个大有改善的版本，其中有几个功能专注于性能。 下面将简单介绍其值得关注的一些新特性。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="Lambda-参数的本地变量语法"><a href="#Lambda-参数的本地变量语法" class="headerlink" title="Lambda 参数的本地变量语法"></a>Lambda 参数的本地变量语法</h3><p>&emsp;&emsp;Lambda 参数的本地变量语法（<a href="http://openjdk.java.net/jeps/323" target="_blank" rel="noopener">JEP 323: Local-Variable Syntax for Lambda Parameters</a>）：在声明隐式类型的 lambda 表达式的形式参数时允许使用 var。</p><p>&emsp;&emsp;为了Java代码更加的简介，Java 10 引入了局部变量类型推断的特性，Java 11对该特性进行了增强，它允许在lamdba表达式中，声明隐式类型参数时使用var保留类型。这样保证了在Java 代码编写时，参数声明方式的一致性。代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(x, y) -&gt; x.process(y)    <span class="comment">//before Java 11</span></span><br><span class="line">(var x, var y) -&gt; x.process(y)   <span class="comment">//Java 11</span></span><br></pre></td></tr></table></figure><h2 id="类库"><a href="#类库" class="headerlink" title="类库"></a>类库</h2><h3 id="HTTP-客户端（标准）"><a href="#HTTP-客户端（标准）" class="headerlink" title="HTTP 客户端（标准）"></a>HTTP 客户端（标准）</h3><p>&emsp;&emsp;HTTP 客户端（标准）（<a href="http://openjdk.java.net/jeps/321" target="_blank" rel="noopener">JEP 321: HTTP Client (Standard)</a>）：通过 JEP 110 标准化 JDK 9 中引入的孵化 HTTP 客户端 API，并在 JDK 10 中进行更新。</p><p>&emsp;&emsp;新版本的HTTP客户端（java.net.http包中） 除了实现了HTTP(1.1和2)、WebSocket，同步和异步调用以及Reactive Streams，还提供了清晰易懂的 Fluent 界面。代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步请求</span></span><br><span class="line">var request = HttpRequest.newBuilder()</span><br><span class="line">    .uri(URI.create(<span class="string">"https://snowolf.gitee.io"</span>))</span><br><span class="line">    .GET()</span><br><span class="line">    .build();</span><br><span class="line">var client = HttpClient.newHttpClient();</span><br><span class="line">HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">System.out.println(response.body());</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步请求</span></span><br><span class="line">var request = HttpRequest.newBuilder()</span><br><span class="line">    .uri(URI.create(<span class="string">"https://snowolf.gitee.io"</span>))</span><br><span class="line">    .build();</span><br><span class="line">var client = HttpClient.newHttpClient();</span><br><span class="line">client.sendAsync(request, HttpResponse.BodyHandlers.ofString())</span><br><span class="line">    .thenApply(HttpResponse::body)</span><br><span class="line">    .thenAccept(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="Unicode-10"><a href="#Unicode-10" class="headerlink" title="Unicode 10"></a>Unicode 10</h3><p>&emsp;&emsp;Unicode 10（<a href="http://openjdk.java.net/jeps/327" target="_blank" rel="noopener">JEP 327: Unicode 10</a>）：升级现有平台 API 以支持<a href="http://unicode.org/versions/Unicode10.0.0/" target="_blank" rel="noopener">Unicode v10.0 标准</a>。<br>&emsp;&emsp;Unicode 10.0 增加了8518 个字符, 总计达到了136,690个字符。并且增加了4个脚本, 总结139个脚本, 同时还有56个新的emoji表情符号。Java 11 主要升级了如下类库，来支持Unicode V10.0标准。</p><ul><li>java.lang包中的Character和String类</li><li>java.awt.font包中的NumericShaper类</li><li>java.text包中的Bidi、BreakIterator和Normalizerl类</li></ul><h3 id="移除-Java-EE-和-CORBA-模块"><a href="#移除-Java-EE-和-CORBA-模块" class="headerlink" title="移除 Java EE 和 CORBA 模块"></a>移除 Java EE 和 CORBA 模块</h3><p>&emsp;&emsp;移除 Java EE 和 CORBA 模块（<a href="http://openjdk.java.net/jeps/320" target="_blank" rel="noopener">JEP 320: Remove the Java EE and CORBA Modules</a>）：从Java SE Platform和JDK中删除Java EE和CORBA模块（JavaFX 也已被移除）。这些模块在Java SE 9中已弃用，声明的目的是为了在将来的版本中删除它们。<br>&emsp;&emsp;Java 11主要删除了如下包：</p><ul><li>java.xml.ws (JAX-WS以及与之相关的SAAJ和Web Services元数据)</li><li>java.xml.bind (JAXB)</li><li>java.activation (JAF)</li><li>java.xml.ws.annotation (Common Annotations)</li><li>java.corba (CORBA)</li><li>java.transaction (JTA)</li></ul><p>同时移除了与之关联的模块，如下：</p><ul><li>java.se.ee (上述六个包的聚合模块)</li><li>jdk.xml.ws (JAX-WS工具)</li><li>jdk.xml.bind (JAXB工具)</li></ul><h3 id="弃用-Nashorn-JavaScript-引擎"><a href="#弃用-Nashorn-JavaScript-引擎" class="headerlink" title="弃用 Nashorn JavaScript 引擎"></a>弃用 Nashorn JavaScript 引擎</h3><p>&emsp;&emsp;弃用 Nashorn JavaScript 引擎（<a href="http://openjdk.java.net/jeps/335" target="_blank" rel="noopener">JEP 335: Deprecate the Nashorn JavaScript Engine</a>）：弃用 Nashorn JavaScript 脚本引擎和 API 以及 jjs 工具，意图在将来的版本中删除它们。</p><p>&emsp;&emsp;Java 11 将如下两个模块标记为了过期（<code>@Deprecated(forRemoval=true)</code>）:</p><ul><li>jdk.scripting.nashorn（含jdk.nashorn.api.scripting和jdk.nashorn.api.tree两个包）</li><li>jdk.scripting.nashorn.shell（含jjsg工具，再执行jjs命令，将会出现过期的警告提示。）</li></ul><h3 id="弃用-Pack200-工具和-API"><a href="#弃用-Pack200-工具和-API" class="headerlink" title="弃用 Pack200 工具和 API"></a>弃用 Pack200 工具和 API</h3><p>&emsp;&emsp;弃用 Pack200 工具和 API（<a href="http://openjdk.java.net/jeps/336" target="_blank" rel="noopener">JEP 336: Deprecate the Pack200 Tools and API</a>）：在 java.util.jar 中弃用 pack200 和 unpack200 工具以及 Pack200 API。<br>&emsp;&emsp;Pack200是当初Sun公司为更快地在网络上传输JAR文件而在JSR 200中提出的一种HTTP压缩方式。 从Sun JDK 1.50版就开始提供的Pack200压缩工具以及Pack200压缩文件。但随着技术的发展，开发人员已经不再需要使用这种压缩技术。主要理由如下：</p><ol><li>JDK 9为Java运行时（JEP 220）和用于构建运行时（JMOD）的模块引入了新的压缩方案。因此，JDK 9及更高版本不依赖Pack200; JDK 8是在构建时使用pack200压缩的最后一个版本，在安装时未使用unpack200解压缩。JDK本身已不再需要Pack200技术。</li><li>客户端应用程序（Applet）的格局已发生变化，大多数浏览器都不再支持插件。Applet不再需要Pack200压缩技术。</li><li>Pack200是一项复杂而精细的技术。文件与类文件格式和JAR文件格式紧密耦合，然而JEP 309在类文件格式中添加了一种新的常量池条目，并且JEP 238将版本控制元数据添加到JAR文件格式。java.util.jar.Pack200中的API对Java SE平台的模块化是有害的，导致在Java SE 9中删除了它的四种方法。总的来说，维护Pack200的成本是巨大的，并且超过了它的好处。包括它在Java SE和JDK中。</li></ol><p>&emsp;&emsp;Java 11 将java.base模块中的如下三个类标记为过期（<code>@Deprecated(forRemoval=true)</code>）:</p><ul><li>java.util.jar.Pack200</li><li>java.util.jar.Pack200.Packer</li><li>java.util.jar.Pack200.Unpacker</li></ul><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><h3 id="基于巢的访问控制"><a href="#基于巢的访问控制" class="headerlink" title="基于巢的访问控制"></a>基于巢的访问控制</h3><p>&emsp;&emsp;基于巢的访问控制（<a href="http://openjdk.java.net/jeps/181" target="_blank" rel="noopener">JEP 181:Nest-Based Access Control</a>）：即“Nestmate”。巢是一种访问控制上下文，与 Java 编程语言中现有的嵌套类型概念一致。 巢允许逻辑上属于同一代码实体，但被编译为不同类文件的类，无需编译器插入可访问性扩展桥接方法，即可访问彼此的私有成员。<br>&emsp;&emsp;Java 11 的巢访问控制引入了“巢（nest）”的概念，同一巢的两个成员（外部类和内部类）是同窝，它们具备同等的访问权限。这就改变了从Java 1.0开始的访问桥(access bridge) 的模式，改善了程序大小和额外性能损耗等问题，让应用程序和字节码更加简单、安全，并对开发者透明。</p><h3 id="动态类文件常量"><a href="#动态类文件常量" class="headerlink" title="动态类文件常量"></a>动态类文件常量</h3><p>&emsp;&emsp;动态类文件常量（<a href="http://openjdk.java.net/jeps/309" target="_blank" rel="noopener">JEP 309: Dynamic Class-File Constants</a>）：扩展 Java 类文件格式以支持新的常量池形式，CONSTANT_Dynamic。 加载　CONSTANT_Dynamic 会将创建委托给 bootstrap 方法，就像链接 invokedynamic 调用站点将链接委托给 bootstrap 方法一样。降低开发新形式的可实现类文件约束带来的成本和干扰。</p><h3 id="改进-Aarch64-内联函数"><a href="#改进-Aarch64-内联函数" class="headerlink" title="改进 Aarch64 内联函数"></a>改进 Aarch64 内联函数</h3><p>&emsp;&emsp;改进 Aarch64 内联函数（<a href="http://openjdk.java.net/jeps/315" target="_blank" rel="noopener">JEP 315: Improve Aarch64 Intrinsics</a>）：改进现有的字符串和数组内联函数，并在 AArch64 处理器上为 java.lang.Math sin，cos 和 log 函数实现新的内联函数。专用的CPU架构的代码模式可提高用户应用程序和基准测试的性能。</p><h3 id="Epsilon-垃圾回收器"><a href="#Epsilon-垃圾回收器" class="headerlink" title="Epsilon 垃圾回收器"></a>Epsilon 垃圾回收器</h3><p>&emsp;&emsp;Epsilon 垃圾回收器（<a href="http://openjdk.java.net/jeps/318" target="_blank" rel="noopener">JEP 318: Epsilon: A No-Op Garbage Collector (Experimental)</a>）：又被称为”No-Op（无操作）”回收器,它仅负责内存分配，却没有实现任何实际的内存回收机制。 一旦可用的 Java 堆耗尽，JVM 将关闭。<br>&emsp;&emsp;Epsilon 垃圾回收器主要用来进行性能测试、内存压力测试等，Epsilon GC可以作为度量其他垃圾回收器性能的对照组。大神Martijn说，Epsilon GC至少能够帮助理解GC的接口，有助于成就一个更加模块化的JVM。</p><h3 id="运行记录仪"><a href="#运行记录仪" class="headerlink" title="运行记录仪"></a>运行记录仪</h3><p>&emsp;&emsp;运行记录仪（<a href="http://openjdk.java.net/jeps/328" target="_blank" rel="noopener">JEP 328: Flight Recorder</a>）：提供低开销的数据收集框架，用于对 Java 应用程序和 HotSpot JVM 进行故障排除。<br>&emsp;&emsp;JFR 是一套集成进入 JDK、JVM 内部的事件机制框架，通过良好架构和设计的框架，硬件层面的极致优化，生产环境的广泛验证，它可以做到极致的可靠和低开销。在<a href="https://www.spec.org/jbb2015/" target="_blank" rel="noopener">SPECjbb2015</a>等基准测试中，JFR 的性能开销最大不超过 1%，所以，工程师可以基本没有心理负担地在大规模分布式的生产系统使用，这意味着，我们既可以随时主动开启 JFR 进行特定诊断，也可以让系统长期运行 JFR，用以在复杂环境中进行“After-the-fact”分析。</p><h3 id="启动单文件源代码程序"><a href="#启动单文件源代码程序" class="headerlink" title="启动单文件源代码程序"></a>启动单文件源代码程序</h3><p>&emsp;&emsp;启动单文件源代码程序（<a href="http://openjdk.java.net/jeps/330" target="_blank" rel="noopener">JEP 330: Launch Single-File Source-Code Programs</a>）：增强 java 启动程序以运行作为 Java 源代码的单个文件提供的程序，包括通过“shebang”文件和相关技术从脚本中使用。<br>&emsp;&emsp;单文件程序是指整个程序只有一个源码文件，通常是早期学习Java阶段，或者写一个小型工具类。以HelloWorld.java为例，运行它之前需要先编译。我们希望Java启动器能直接运行这个源码级的程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java HelloWorld.java</span><br></pre></td></tr></table></figure><h3 id="低开销的堆分配采样方法"><a href="#低开销的堆分配采样方法" class="headerlink" title="低开销的堆分配采样方法"></a>低开销的堆分配采样方法</h3><p>&emsp;&emsp;低开销的堆分配采样方法（<a href="http://openjdk.java.net/jeps/331" target="_blank" rel="noopener">JEP 331: Low-Overhead Heap Profiling</a>）：提供一种低开销的 Java 堆分配采样方法，可通过 JVMTI 访问。<br>&emsp;&emsp;我们知道，高效地了解在 Java 堆上都进行了哪些对象分配，是诊断内存问题的基本出发点之一。 JEP 331 来源于 Google 等业界前沿厂商的一线实践，通过获取对象分配的 Call-site，为 JDK 补足了对象分配诊断方面的一些短板，工程师可以通过 JVMTI 使用这个能力增强自身的工具。</p><h3 id="ZGC：可扩展的低延迟垃圾收集器"><a href="#ZGC：可扩展的低延迟垃圾收集器" class="headerlink" title="ZGC：可扩展的低延迟垃圾收集器"></a>ZGC：可扩展的低延迟垃圾收集器</h3><p>&emsp;&emsp;ZGC：可扩展的低延迟垃圾收集器（<a href="http://openjdk.java.net/jeps/333" target="_blank" rel="noopener">JEP 333: ZGC: A Scalable Low-Latency Garbage Collector (Experimental)</a>）：Z垃圾收集器，也称为 ZGC，是一个可扩展的低延迟垃圾收集器。<br>&emsp;&emsp;从 JVM GC 的角度，JDK 11 引入了两种新的 GC，其中包括也许是划时代意义的 ZGC，虽然其目前还是实验特性，但是从能力上来看，这是 OpenJDK 的一个巨大突破，为特定生产环境的苛刻需求提供了一个可能的选择。例如，对部分企业核心存储等产品，如果能够保证不超过 10ms 的 GC 暂停，可靠性会上一个大的台阶，这是过去我们进行 GC 调优几乎做不到的，是能与不能的问题。</p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><h3 id="采用-Curve25519-和-Curve448-算法实现的密钥协议"><a href="#采用-Curve25519-和-Curve448-算法实现的密钥协议" class="headerlink" title="采用 Curve25519 和 Curve448 算法实现的密钥协议"></a>采用 Curve25519 和 Curve448 算法实现的密钥协议</h3><p>&emsp;&emsp;采用 Curve25519 和 Curve448 算法实现的密钥协议（<a href="http://openjdk.java.net/jeps/324" target="_blank" rel="noopener">JEP 324: Key Agreement with Curve25519 and Curve448</a>）：使用<a href="https://tools.ietf.org/html/rfc7748" target="_blank" rel="noopener">RFC 7748</a> 中描述的 Curve25519 和 Curve448 实现密钥协议。<br>&emsp;&emsp;密码学要求使用 Curve25519 和Curve448 是因为它们的安全性和性能。JDK会增加两个新的接口XECPublicKey 和 XECPrivateKey，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">KeyPairGenerator kpg = KeyPairGenerator.getInstance(<span class="string">"XDH"</span>);</span><br><span class="line">NamedParameterSpec paramSpec = <span class="keyword">new</span> NamedParameterSpec(<span class="string">"X25519"</span>);</span><br><span class="line">kpg.initialize(paramSpec); <span class="comment">// equivalent to kpg.initialize(255)</span></span><br><span class="line"><span class="comment">// alternatively: kpg = KeyPairGenerator.getInstance("X25519")</span></span><br><span class="line">KeyPair kp = kpg.generateKeyPair();</span><br><span class="line"></span><br><span class="line">KeyFactory kf = KeyFactory.getInstance(<span class="string">"XDH"</span>);</span><br><span class="line">BigInteger u = ...</span><br><span class="line">XECPublicKeySpec pubSpec = <span class="keyword">new</span> XECPublicKeySpec(paramSpec, u);</span><br><span class="line">PublicKey pubKey = kf.generatePublic(pubSpec);</span><br><span class="line"></span><br><span class="line">KeyAgreement ka = KeyAgreement.getInstance(<span class="string">"XDH"</span>);</span><br><span class="line">ka.init(kp.getPrivate());</span><br><span class="line">ka.doPhase(pubKey, <span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">byte</span>[] secret = ka.generateSecret();</span><br></pre></td></tr></table></figure><h3 id="实现-ChaCha20-和-Poly1305-加密算法"><a href="#实现-ChaCha20-和-Poly1305-加密算法" class="headerlink" title="实现 ChaCha20 和 Poly1305 加密算法"></a>实现 ChaCha20 和 Poly1305 加密算法</h3><p>&emsp;&emsp;实现 ChaCha20 和 Poly1305 加密算法（<a href="http://openjdk.java.net/jeps/329" target="_blank" rel="noopener">JEP 329: ChaCha20 and Poly1305 Cryptographic Algorithms</a>）：实现<a href="https://tools.ietf.org/html/rfc7539" target="_blank" rel="noopener">RFC 7539</a>中指定的 ChaCha20 和 ChaCha20-Poly1305 密码。ChaCha20 是一种相对较新的流密码，可以替代旧的、不安全的 RC4 流密码。<br>基于ChaCha20加密算法的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get a Cipher instance and set up the parameters</span></span><br><span class="line"><span class="comment">// Assume SecretKey "key", 12-byte nonce "nonceBytes" and plaintext "pText"</span></span><br><span class="line"><span class="comment">// are coming from outside this code snippet</span></span><br><span class="line">Cipher mambo = Cipher.getInstance(<span class="string">"ChaCha20"</span>);</span><br><span class="line">ChaCha20ParameterSpec mamboSpec</span><br><span class="line">    = <span class="keyword">new</span> ChaCha20ParameterSpec(nonceBytes, <span class="number">7</span>);   <span class="comment">// Use a starting counter value of "7"</span></span><br><span class="line"><span class="comment">// Encrypt our input</span></span><br><span class="line">mambo.init(Cipher.ENCRYPT_MODE, key, mamboSpec);</span><br><span class="line"><span class="keyword">byte</span>[] encryptedResult = mambo.doFinal(pText);</span><br></pre></td></tr></table></figure><p>基于ChaCha20-Poly1305加密算法的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get a Cipher instance and set up the parameters</span></span><br><span class="line"><span class="comment">// Assume SecretKey "key", 12-byte nonce "nonceBytes" and plaintext "pText"</span></span><br><span class="line"><span class="comment">// are coming from outside this code snippet</span></span><br><span class="line">Cipher mambo = Cipher.getInstance(<span class="string">"ChaCha20-Poly1305"</span>);</span><br><span class="line">AlgorithmParameterSpec mamboSpec = <span class="keyword">new</span> IvParameterSpec(nonceBytes);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Encrypt our input</span></span><br><span class="line">mambo.init(Cipher.ENCRYPT_MODE, key, mamboSpec);</span><br><span class="line"><span class="keyword">byte</span>[] encryptedResult = <span class="keyword">new</span> <span class="keyword">byte</span>[mambo.getOutputSize(pText.length)];</span><br><span class="line">mambo.doFinal(pText, <span class="number">0</span>, pText.length, encryptedResult);</span><br></pre></td></tr></table></figure><h3 id="传输层安全性（TLS）1-3"><a href="#传输层安全性（TLS）1-3" class="headerlink" title="传输层安全性（TLS）1.3"></a>传输层安全性（TLS）1.3</h3><p>&emsp;&emsp;传输层安全性（TLS）1.3（<a href="http://openjdk.java.net/jeps/332" target="_blank" rel="noopener">JEP 332: Transport Layer Security (TLS) 1.3</a>）：实现传输层安全性（TLS）协议<a href="https://tools.ietf.org/html/rfc8446" target="_blank" rel="noopener">RFC 8446</a> 的 1.3 版。<br>&emsp;&emsp;TLS 1.3是TLS协议的重大改进，与以前的版本相比，它提供了显着的安全性和性能改进。其他供应商的几个早期实现已经可用。我们需要支持TLS 1.3以保持竞争力并与最新标准保持同步。这个特性的实现动机和Unicode 10一样，也是紧跟历史潮流。</p><p>&emsp;&emsp;以上就是Java 11的主要新特性，如果想详细了解这些新特性对开发带来的帮助和使用方法，请持续关注本系列博客。</p>]]></content>
    
    <summary type="html">
    
      2018年9月25日（美国当地时间），Oracle发布了Java SE 11（18.9）（JSR 384）版本。这是继2014年3月发布Java SE 8之后的首个长期支持版本（LTS），根据后续的发布计划，下一个长期支持版本要到2021年9月才会发布。因此Java SE 11 是一个值得关注和学习的版本。本文将简单介绍该版本引入的新特性，在后续文章中将会对每一个新特性进行详细介绍。
    
    </summary>
    
      <category term="IT技术" scheme="https://snowolf.gitee.io/categories/IT%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://snowolf.gitee.io/categories/IT%E6%8A%80%E6%9C%AF/Java/"/>
    
    
      <category term="IT技术" scheme="https://snowolf.gitee.io/tags/IT%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://snowolf.gitee.io/tags/Java/"/>
    
      <category term="新特性" scheme="https://snowolf.gitee.io/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
</feed>
