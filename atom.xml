<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>焰冰封</title>
  
  <subtitle>个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://snowolf.gitee.io/"/>
  <updated>2018-09-29T11:08:58.255Z</updated>
  <id>https://snowolf.gitee.io/</id>
  
  <author>
    <name>Snowolf Lee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 11 新特性预览</title>
    <link href="https://snowolf.gitee.io/2018/09/29/1/"/>
    <id>https://snowolf.gitee.io/2018/09/29/1/</id>
    <published>2018-09-29T04:19:19.000Z</published>
    <updated>2018-09-29T11:08:58.255Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;2018年是Java新版本发布比较频繁的一年，距2018年3月发布 Java 10 版本6个月后，Oracle发布了Java 11(18.9) (<a href="http://cr.openjdk.java.net/~iris/se/11/latestSpec/" target="_blank" rel="noopener">JSR 384</a>)。值得注意的是，和Java 9 和 Java 10 这两个被称为“功能性的版本”不同（两者均只提供半年的技术支持），Java 11 不仅提供了长期支持服务，还将作为 Java 平台的参考实现。Oracle直到2023年9月都会为 Java 11 提供技术支持，而补丁和安全警告等扩展支持将持续到2026年。新的长期支持版本每三年发布一次，根据后续的发布计划，下一个长期支持版 Java 17 将于2021年发布。<br><br>&emsp;&emsp;Java Development Kit（JDK）11 （<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk11-downloads-5066655.html" target="_blank" rel="noopener">下载</a>） 不仅仅是一个升级版。 它是 Java 语言的一个大有改善的版本，其中有几个功能专注于性能。 下面将简单介绍其值得关注的一些新特性。<br></p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="Lambda-参数的本地变量语法"><a href="#Lambda-参数的本地变量语法" class="headerlink" title="Lambda 参数的本地变量语法"></a>Lambda 参数的本地变量语法</h3><p>&emsp;&emsp;Lambda 参数的本地变量语法（<a href="http://openjdk.java.net/jeps/323" target="_blank" rel="noopener">JEP 323: Local-Variable Syntax for Lambda Parameters</a>）：在声明隐式类型的 lambda 表达式的形式参数时允许使用 var。<br><br>&emsp;&emsp;为了Java代码更加的简介，Java 10 引入了局部变量类型推断的特性，Java 11对该特性进行了增强，它允许在lamdba表达式中，声明隐式类型参数时使用var关键字。这样保证了在Java 代码编写时，参数声明方式的一致性。代码如下所示：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(x, y) -&gt; x.process(y)    <span class="comment">//before Java 11</span></span><br><span class="line">(var x, var y) -&gt; x.process(y)   <span class="comment">//Java 11</span></span><br></pre></td></tr></table></figure></p><h2 id="类库"><a href="#类库" class="headerlink" title="类库"></a>类库</h2><h3 id="HTTP-客户端（标准）"><a href="#HTTP-客户端（标准）" class="headerlink" title="HTTP 客户端（标准）"></a>HTTP 客户端（标准）</h3><p>&emsp;&emsp;HTTP 客户端（标准）（<a href="http://openjdk.java.net/jeps/321" target="_blank" rel="noopener">JEP 321: HTTP Client (Standard)</a>）：通过 JEP 110 标准化 JDK 9 中引入的孵化 HTTP 客户端 API，并在 JDK 10 中进行更新。<br><br>&emsp;&emsp;新版本的HTTP客户端（java.net.http包中） 除了实现了HTTP(1.1和2)、WebSocket，同步和异步调用以及Reactive Streams，还提供了清晰易懂的 Fluent 界面。代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步请求</span></span><br><span class="line">var request = HttpRequest.newBuilder()</span><br><span class="line">    .uri(URI.create(<span class="string">"https://snowolf.gitee.io"</span>))</span><br><span class="line">    .GET()</span><br><span class="line">    .build();</span><br><span class="line">var client = HttpClient.newHttpClient();</span><br><span class="line">HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">System.out.println(response.body());</span><br><span class="line"><span class="comment">//异步请求</span></span><br><span class="line">var request = HttpRequest.newBuilder()</span><br><span class="line">    .uri(URI.create(<span class="string">"https://snowolf.gitee.io"</span>))</span><br><span class="line">    .build();</span><br><span class="line">var client = HttpClient.newHttpClient();</span><br><span class="line">client.sendAsync(request, HttpResponse.BodyHandlers.ofString())</span><br><span class="line">    .thenApply(HttpResponse::body)</span><br><span class="line">    .thenAccept(System.out::println);</span><br></pre></td></tr></table></figure></p><h3 id="Unicode-10"><a href="#Unicode-10" class="headerlink" title="Unicode 10"></a>Unicode 10</h3><p>&emsp;&emsp;Unicode 10（<a href="http://openjdk.java.net/jeps/327" target="_blank" rel="noopener">JEP 327: Unicode 10</a>）：升级现有平台 API 以支持<a href="http://unicode.org/versions/Unicode10.0.0/" target="_blank" rel="noopener">Unicode v10.0 标准</a>。<br><br>&emsp;&emsp;Unicode 10.0 增加了8518 个字符, 总计达到了136,690个字符。并且增加了4个脚本, 总结139个脚本, 同时还有56个新的emoji表情符号。Java 11 主要升级了如下类库，来支持Unicode V10.0标准。<br></p><ul><li>java.lang包中的Character和String类</li><li>java.awt.font包中的NumericShaper类</li><li>java.text包中的Bidi、BreakIterator和Normalizerl类</li></ul><h3 id="移除-Java-EE-和-CORBA-模块"><a href="#移除-Java-EE-和-CORBA-模块" class="headerlink" title="移除 Java EE 和 CORBA 模块"></a>移除 Java EE 和 CORBA 模块</h3><p>&emsp;&emsp;移除 Java EE 和 CORBA 模块（<a href="http://openjdk.java.net/jeps/320" target="_blank" rel="noopener">JEP 320: Remove the Java EE and CORBA Modules</a>）：从Java SE Platform和JDK中删除Java EE和CORBA模块（JavaFX 也已被移除）。这些模块在Java SE 9中已弃用，声明的目的是为了在将来的版本中删除它们。<br><br>&emsp;&emsp;Java 11主要删除了如下包：</p><ul><li>java.xml.ws (JAX-WS以及与之相关的SAAJ和Web Services元数据)</li><li>java.xml.bind (JAXB)</li><li>java.activation (JAF)</li><li>java.xml.ws.annotation (Common Annotations)</li><li>java.corba (CORBA)</li><li>java.transaction (JTA)<br><br>同时移除了与之关联的模块，如下：</li><li>java.se.ee (上述六个包的聚合模块)</li><li>jdk.xml.ws (JAX-WS工具)</li><li>jdk.xml.bind (JAXB工具)<h3 id="弃用-Nashorn-JavaScript-引擎"><a href="#弃用-Nashorn-JavaScript-引擎" class="headerlink" title="弃用 Nashorn JavaScript 引擎"></a>弃用 Nashorn JavaScript 引擎</h3>&emsp;&emsp;弃用 Nashorn JavaScript 引擎（<a href="http://openjdk.java.net/jeps/335" target="_blank" rel="noopener">JEP 335: Deprecate the Nashorn JavaScript Engine</a>）：弃用 Nashorn JavaScript 脚本引擎和 API 以及 jjs 工具，意图在将来的版本中删除它们。<br><br>&emsp;&emsp;Java 11 将如下两个模块标记为了过期（<code>@Deprecated(forRemoval=true)</code>）:</li><li>jdk.scripting.nashorn（含jdk.nashorn.api.scripting和jdk.nashorn.api.tree两个包）</li><li>jdk.scripting.nashorn.shell（含jjsg工具，再执行jjs命令，将会出现过期的警告提示。）<h3 id="弃用-Pack200-工具和-API"><a href="#弃用-Pack200-工具和-API" class="headerlink" title="弃用 Pack200 工具和 API"></a>弃用 Pack200 工具和 API</h3>&emsp;&emsp;弃用 Pack200 工具和 API（<a href="http://openjdk.java.net/jeps/336" target="_blank" rel="noopener">JEP 336: Deprecate the Pack200 Tools and API</a>）：在 java.util.jar 中弃用 pack200 和 unpack200 工具以及 Pack200 API。<br><br>&emsp;&emsp;Pack200是当初Sun公司为更快地在网络上传输JAR文件而在JSR 200中提出的一种HTTP压缩方式。 从Sun JDK 1.50版就开始提供的Pack200压缩工具以及Pack200压缩文件。但随着技术的发展，开发人员已经不再需要使用这种压缩技术。主要理由如下：</li></ul><ol><li>JDK 9为Java运行时（JEP 220）和用于构建运行时（JMOD）的模块引入了新的压缩方案。因此，JDK 9及更高版本不依赖Pack200; JDK 8是在构建时使用pack200压缩的最后一个版本，在安装时未使用unpack200解压缩。JDK本身已不再需要Pack200技术。</li><li>客户端应用程序（Applet）的格局已发生变化，大多数浏览器都不再支持插件。Applet不再需要Pack200压缩技术。</li><li>Pack200是一项复杂而精细的技术。文件与类文件格式和JAR文件格式紧密耦合，然而JEP 309在类文件格式中添加了一种新的常量池条目，并且JEP 238将版本控制元数据添加到JAR文件格式。java.util.jar.Pack200中的API对Java SE平台的模块化是有害的，导致在Java SE 9中删除了它的四种方法。总的来说，维护Pack200的成本是巨大的，并且超过了它的好处。包括它在Java SE和JDK中。</li></ol><p>&emsp;&emsp;Java 11 将java.base模块中的如下三个类标记为过期（<code>@Deprecated(forRemoval=true)</code>）:</p><ul><li>java.util.jar.Pack200</li><li>java.util.jar.Pack200.Packer</li><li>java.util.jar.Pack200.Unpacker</li></ul><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><h3 id="基于巢的访问控制"><a href="#基于巢的访问控制" class="headerlink" title="基于巢的访问控制"></a>基于巢的访问控制</h3><p>&emsp;&emsp;基于巢的访问控制（<a href="http://openjdk.java.net/jeps/181" target="_blank" rel="noopener">JEP 181:Nest-Based Access Control</a>）：即“Nestmate”。巢是一种访问控制上下文，与 Java 编程语言中现有的嵌套类型概念一致。 巢允许逻辑上属于同一代码实体，但被编译为不同类文件的类，无需编译器插入可访问性扩展桥接方法，即可访问彼此的私有成员。<br><br>&emsp;&emsp;Java 11 的巢访问控制引入了“巢（nest）”的概念，同一巢的两个成员（外部类和内部类）是同窝，它们具备同等的访问权限。这就改变了从Java 1.0开始的访问桥(access bridge) 的模式，改善了程序大小和额外性能损耗等问题，让应用程序和字节码更加简单、安全，并对开发者透明。</p><h3 id="动态类文件常量"><a href="#动态类文件常量" class="headerlink" title="动态类文件常量"></a>动态类文件常量</h3><p>&emsp;&emsp;动态类文件常量（<a href="http://openjdk.java.net/jeps/309" target="_blank" rel="noopener">JEP 309: Dynamic Class-File Constants</a>）：扩展 Java 类文件格式以支持新的常量池形式，CONSTANT_Dynamic。 加载　CONSTANT_Dynamic 会将创建委托给 bootstrap 方法，就像链接 invokedynamic 调用站点将链接委托给 bootstrap 方法一样。降低开发新形式的可实现类文件约束带来的成本和干扰。<br><br>&emsp;&emsp;</p><h3 id="改进-Aarch64-内联函数"><a href="#改进-Aarch64-内联函数" class="headerlink" title="改进 Aarch64 内联函数"></a>改进 Aarch64 内联函数</h3><p>&emsp;&emsp;改进 Aarch64 内联函数（<a href="http://openjdk.java.net/jeps/315" target="_blank" rel="noopener">JEP 315: Improve Aarch64 Intrinsics</a>）：改进现有的字符串和数组内联函数，并在 AArch64 处理器上为 java.lang.Math sin，cos 和 log 函数实现新的内联函数。专用的CPU架构的代码模式可提高用户应用程序和基准测试的性能。</p><h3 id="Epsilon-垃圾回收器"><a href="#Epsilon-垃圾回收器" class="headerlink" title="Epsilon 垃圾回收器"></a>Epsilon 垃圾回收器</h3><p>&emsp;&emsp;Epsilon 垃圾回收器（<a href="http://openjdk.java.net/jeps/318" target="_blank" rel="noopener">JEP 318: Epsilon: A No-Op Garbage Collector (Experimental)</a>）：又被称为”No-Op（无操作）”回收器,它仅负责内存分配，却没有实现任何实际的内存回收机制。 一旦可用的 Java 堆耗尽，JVM 将关闭。<br><br>&emsp;&emsp;Epsilon 垃圾回收器主要用来进行性能测试、内存压力测试等，Epsilon GC可以作为度量其他垃圾回收器性能的对照组。大神Martijn说，Epsilon GC至少能够帮助理解GC的接口，有助于成就一个更加模块化的JVM。</p><h3 id="运行记录仪"><a href="#运行记录仪" class="headerlink" title="运行记录仪"></a>运行记录仪</h3><p>&emsp;&emsp;运行记录仪（<a href="http://openjdk.java.net/jeps/328" target="_blank" rel="noopener">JEP 328: Flight Recorder</a>）：提供低开销的数据收集框架，用于对 Java 应用程序和 HotSpot JVM 进行故障排除。<br><br>&emsp;&emsp;JFR 是一套集成进入 JDK、JVM 内部的事件机制框架，通过良好架构和设计的框架，硬件层面的极致优化，生产环境的广泛验证，它可以做到极致的可靠和低开销。在<a href="https://www.spec.org/jbb2015/" target="_blank" rel="noopener">SPECjbb2015</a>等基准测试中，JFR 的性能开销最大不超过 1%，所以，工程师可以基本没有心理负担地在大规模分布式的生产系统使用，这意味着，我们既可以随时主动开启 JFR 进行特定诊断，也可以让系统长期运行 JFR，用以在复杂环境中进行“After-the-fact”分析。</p><h3 id="启动单文件源代码程序"><a href="#启动单文件源代码程序" class="headerlink" title="启动单文件源代码程序"></a>启动单文件源代码程序</h3><p>&emsp;&emsp;启动单文件源代码程序（<a href="http://openjdk.java.net/jeps/330" target="_blank" rel="noopener">JEP 330: Launch Single-File Source-Code Programs</a>）：增强 java 启动程序以运行作为 Java 源代码的单个文件提供的程序，包括通过“shebang”文件和相关技术从脚本中使用。<br><br>&emsp;&emsp;单文件程序是指整个程序只有一个源码文件，通常是早期学习Java阶段，或者写一个小型工具类。以HelloWorld.java为例，运行它之前需要先编译。我们希望Java启动器能直接运行这个源码级的程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java HelloWorld.java</span><br></pre></td></tr></table></figure></p><h3 id="低开销的堆分配采样方法"><a href="#低开销的堆分配采样方法" class="headerlink" title="低开销的堆分配采样方法"></a>低开销的堆分配采样方法</h3><p>&emsp;&emsp;低开销的堆分配采样方法（<a href="http://openjdk.java.net/jeps/331" target="_blank" rel="noopener">JEP 331: Low-Overhead Heap Profiling</a>）：提供一种低开销的 Java 堆分配采样方法，可通过 JVMTI 访问。<br><br>&emsp;&emsp;我们知道，高效地了解在 Java 堆上都进行了哪些对象分配，是诊断内存问题的基本出发点之一。 JEP 331 来源于 Google 等业界前沿厂商的一线实践，通过获取对象分配的 Call-site，为 JDK 补足了对象分配诊断方面的一些短板，工程师可以通过 JVMTI 使用这个能力增强自身的工具。</p><h3 id="ZGC：可扩展的低延迟垃圾收集器"><a href="#ZGC：可扩展的低延迟垃圾收集器" class="headerlink" title="ZGC：可扩展的低延迟垃圾收集器"></a>ZGC：可扩展的低延迟垃圾收集器</h3><p>&emsp;&emsp;ZGC：可扩展的低延迟垃圾收集器（<a href="http://openjdk.java.net/jeps/333" target="_blank" rel="noopener">JEP 333: ZGC: A Scalable Low-Latency Garbage Collector (Experimental)</a>）：Z垃圾收集器，也称为 ZGC，是一个可扩展的低延迟垃圾收集器。<br><br>&emsp;&emsp;从 JVM GC 的角度，JDK 11 引入了两种新的 GC，其中包括也许是划时代意义的 ZGC，虽然其目前还是实验特性，但是从能力上来看，这是 OpenJDK 的一个巨大突破，为特定生产环境的苛刻需求提供了一个可能的选择。例如，对部分企业核心存储等产品，如果能够保证不超过 10ms 的 GC 暂停，可靠性会上一个大的台阶，这是过去我们进行 GC 调优几乎做不到的，是能与不能的问题。</p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><h3 id="采用-Curve25519-和-Curve448-算法实现的密钥协议"><a href="#采用-Curve25519-和-Curve448-算法实现的密钥协议" class="headerlink" title="采用 Curve25519 和 Curve448 算法实现的密钥协议"></a>采用 Curve25519 和 Curve448 算法实现的密钥协议</h3><p>&emsp;&emsp;采用 Curve25519 和 Curve448 算法实现的密钥协议（<a href="http://openjdk.java.net/jeps/324" target="_blank" rel="noopener">JEP 324: Key Agreement with Curve25519 and Curve448</a>）：使用<a href="https://tools.ietf.org/html/rfc7748" target="_blank" rel="noopener">RFC 7748</a> 中描述的 Curve25519 和 Curve448 实现密钥协议。<br><br>&emsp;&emsp;密码学要求使用 Curve25519 和Curve448 是因为它们的安全性和性能。JDK会增加两个新的接口XECPublicKey 和 XECPrivateKey，示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">KeyPairGenerator kpg = KeyPairGenerator.getInstance(<span class="string">"XDH"</span>);</span><br><span class="line">NamedParameterSpec paramSpec = <span class="keyword">new</span> NamedParameterSpec(<span class="string">"X25519"</span>);</span><br><span class="line">kpg.initialize(paramSpec); <span class="comment">// equivalent to kpg.initialize(255)</span></span><br><span class="line"><span class="comment">// alternatively: kpg = KeyPairGenerator.getInstance("X25519")</span></span><br><span class="line">KeyPair kp = kpg.generateKeyPair();</span><br><span class="line"></span><br><span class="line">KeyFactory kf = KeyFactory.getInstance(<span class="string">"XDH"</span>);</span><br><span class="line">BigInteger u = ...</span><br><span class="line">XECPublicKeySpec pubSpec = <span class="keyword">new</span> XECPublicKeySpec(paramSpec, u);</span><br><span class="line">PublicKey pubKey = kf.generatePublic(pubSpec);</span><br><span class="line"></span><br><span class="line">KeyAgreement ka = KeyAgreement.getInstance(<span class="string">"XDH"</span>);</span><br><span class="line">ka.init(kp.getPrivate());</span><br><span class="line">ka.doPhase(pubKey, <span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">byte</span>[] secret = ka.generateSecret();</span><br></pre></td></tr></table></figure></p><h3 id="实现-ChaCha20-和-Poly1305-加密算法"><a href="#实现-ChaCha20-和-Poly1305-加密算法" class="headerlink" title="实现 ChaCha20 和 Poly1305 加密算法"></a>实现 ChaCha20 和 Poly1305 加密算法</h3><p>&emsp;&emsp;实现 ChaCha20 和 Poly1305 加密算法（<a href="http://openjdk.java.net/jeps/329" target="_blank" rel="noopener">JEP 329: ChaCha20 and Poly1305 Cryptographic Algorithms</a>）：实现<a href="https://tools.ietf.org/html/rfc7539" target="_blank" rel="noopener">RFC 7539</a>中指定的 ChaCha20 和 ChaCha20-Poly1305 密码。ChaCha20 是一种相对较新的流密码，可以替代旧的、不安全的 RC4 流密码。<br><br>基于ChaCha20加密算法的示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get a Cipher instance and set up the parameters</span></span><br><span class="line"><span class="comment">// Assume SecretKey "key", 12-byte nonce "nonceBytes" and plaintext "pText"</span></span><br><span class="line"><span class="comment">// are coming from outside this code snippet</span></span><br><span class="line">Cipher mambo = Cipher.getInstance(<span class="string">"ChaCha20"</span>);</span><br><span class="line">ChaCha20ParameterSpec mamboSpec</span><br><span class="line">    = <span class="keyword">new</span> ChaCha20ParameterSpec(nonceBytes, <span class="number">7</span>);   <span class="comment">// Use a starting counter value of "7"</span></span><br><span class="line"><span class="comment">// Encrypt our input</span></span><br><span class="line">mambo.init(Cipher.ENCRYPT_MODE, key, mamboSpec);</span><br><span class="line"><span class="keyword">byte</span>[] encryptedResult = mambo.doFinal(pText);</span><br></pre></td></tr></table></figure></p><p>基于ChaCha20-Poly1305加密算法的示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get a Cipher instance and set up the parameters</span></span><br><span class="line"><span class="comment">// Assume SecretKey "key", 12-byte nonce "nonceBytes" and plaintext "pText"</span></span><br><span class="line"><span class="comment">// are coming from outside this code snippet</span></span><br><span class="line">Cipher mambo = Cipher.getInstance(<span class="string">"ChaCha20-Poly1305"</span>);</span><br><span class="line">AlgorithmParameterSpec mamboSpec = <span class="keyword">new</span> IvParameterSpec(nonceBytes);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Encrypt our input</span></span><br><span class="line">mambo.init(Cipher.ENCRYPT_MODE, key, mamboSpec);</span><br><span class="line"><span class="keyword">byte</span>[] encryptedResult = <span class="keyword">new</span> <span class="keyword">byte</span>[mambo.getOutputSize(pText.length)];</span><br><span class="line">mambo.doFinal(pText, <span class="number">0</span>, pText.length, encryptedResult);</span><br></pre></td></tr></table></figure></p><h2 id="传输层安全性（TLS）1-3"><a href="#传输层安全性（TLS）1-3" class="headerlink" title="传输层安全性（TLS）1.3"></a>传输层安全性（TLS）1.3</h2><p>&emsp;&emsp;传输层安全性（TLS）1.3（<a href="http://openjdk.java.net/jeps/332" target="_blank" rel="noopener">JEP 332: Transport Layer Security (TLS) 1.3</a>）：实现传输层安全性（TLS）协议<a href="https://tools.ietf.org/html/rfc8446" target="_blank" rel="noopener">RFC 8446</a> 的 1.3 版。<br><br>&emsp;&emsp;TLS 1.3是TLS协议的重大改进，与以前的版本相比，它提供了显着的安全性和性能改进。其他供应商的几个早期实现已经可用。我们需要支持TLS 1.3以保持竞争力并与最新标准保持同步。这个特性的实现动机和Unicode 10一样，也是紧跟历史潮流。<br></p><p>&emsp;&emsp;以上就是Java 11的主要新特性，如果想详细了解这些新特性对开发带来的帮助和使用方法，请持续关注本系列博客。</p>]]></content>
    
    <summary type="html">
    
      2018年9月25日（美国当地时间），Oracle发布了Java SE 11（18.9）（JSR 384）版本。这是继2014年3月发布Java SE 8之后的首个长期支持版本（LTS），根据后续的发布计划，下一个长期支持版本要到2021年9月才会发布。因此Java SE 11 是一个值得关注和学习的版本。本文将简单介绍该版本引入的新特性，在后续文章中将会对每一个新特性进行详细介绍。
    
    </summary>
    
      <category term="IT技术" scheme="https://snowolf.gitee.io/categories/IT%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://snowolf.gitee.io/categories/IT%E6%8A%80%E6%9C%AF/Java/"/>
    
    
      <category term="IT技术" scheme="https://snowolf.gitee.io/tags/IT%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://snowolf.gitee.io/tags/Java/"/>
    
      <category term="新特性" scheme="https://snowolf.gitee.io/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
</feed>
